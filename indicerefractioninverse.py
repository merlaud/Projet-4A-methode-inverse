# -*- coding: utf-8 -*-
"""IndiceRefractionInverse.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A2Bw-1Z9z3ZOMkHXPrW6xJ27NFHjzcXQ
"""

pip install shapely

pip install PyMieScatt

import PyMieScatt as ps
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
import numpy.linalg as npl
import scipy.sparse.linalg as spl
from scipy.sparse import diags
from PyMieScatt.Mie import Mie_ab
from time import time
import matplotlib.colors as colors
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from scipy.ndimage import zoom

"""# Step 1: Plot the particle size distribution """

def lognormal(d,sigma):
    d_size = len(d)
    d_mean = (1/d_size)*sum(d)
    q = np.zeros(d_size)
    l = -(np.log(d)+np.log(d_mean))**2/2*sigma**2
    for i in range(d_size):
        q[i] = (1/(np.sqrt(2*np.pi)*d[i]*sigma))*np.exp(-(np.log(d[i])-np.log(d_mean))**2/(2*sigma**2))
    return q

def ultrasound(d):
    d_size = len(d)
    d_mean = (1/d_size)*sum(d)
    q = (128/(3*d_mean**4))*d**3*np.exp(-4*d/d_mean)
    return q

def RRSB(d,n):
    d_size = len(d)
    d_mean = (1/d_size)*sum(d)
    q = (n/d_mean)*((d/d_mean)**(n-1))*np.exp(-(d/d_mean)**n)
    return q

d = np.linspace(0.01,10,100)
wl = 514.5
m = 1.33 
a = np.pi*d/wl

q1 = lognormal(d,0.2)
q2 = ultrasound(d)
q3 = RRSB(d,9)

plt.figure()
plt.plot(d,q1,label="Lognormale")
plt.plot(d,q2,label="Ultrasound")
plt.plot(d,q3,label="RRSB")
plt.title("Particle size Distribution (PSD)")
plt.xlabel("Diameter (in $\mu$m)")
plt.ylabel("frequency")
plt.legend()

"""# Step 2: Plot the scattered intensity according to the scattering angle
#### (commented because really long to compute)

#### For various PSD and a fixed number of nodes (400)

dp = np.linspace(100,1e5,400)
wl = 514.5
m = 1.33 
alpha = 9
sigma = 0.2

ndp_u = ultrasound(dp)
ndp_rrbs = RRSB(dp,alpha)
ndp_ln = lognormal(dp,sigma)

theta1,SL1,SR1,SU1 = ps.SF_SD(m,wl,dp,ndp_u)
theta2,SL2,SR2,SU2 = ps.SF_SD(m,wl,dp,ndp_rrbs)
theta3,SL3,SR3,SU3 = ps.SF_SD(m,wl,dp,ndp_ln)

plt.figure()
plt.semilogy(theta1,SL1,label="ultrasound")
plt.semilogy(theta2,SL2,label="RRSB")
plt.semilogy(theta3,SL3,label="lognormale")
plt.title("Scattered intensity (SL) according to $\\theta$")
plt.legend()
plt.show()


plt.figure()
plt.semilogy(theta1,SR1,label="ultrasound")
plt.semilogy(theta2,SR2,label="RRSB")
plt.semilogy(theta3,SR3,label="lognormale")
plt.title("Scattered intensity (SR) according to $\\theta$")
plt.legend()
plt.show()

plt.figure()
plt.semilogy(theta1,SU1,label="ultrasound")
plt.semilogy(theta2,SU2,label="RRSB")
plt.semilogy(theta3,SU3,label="lognormale")
plt.title("Scattered intensity (SU) according to $\\theta$")
plt.legend()
plt.show()

#### For a fixed PSD (ultrasound) and an increasing number of nodes

dp1 = np.linspace(100,1e5,10)
dp2 = np.linspace(100,1e5,100)
dp3 = np.linspace(100,1e5,200)
wl = 514.5
m = 1.33 

ndp1 = ultrasound(dp1)
ndp2 = ultrasound(dp2)
ndp3 = ultrasound(dp3)

theta1,SL1,SR1,SU1 = SF_SD(m,wl,dp1,ndp1)
theta2,SL2,SR2,SU2 = SF_SD(m,wl,dp2,ndp2)
theta3,SL3,SR3,SU3 = ps.SF_SD(m,wl,dp3,ndp3)

plt.figure()
plt.semilogy(180/np.pi*theta1,SL1,label="nodes=20")
plt.semilogy(180/np.pi*theta2,SL2,label="nodes=100")
plt.semilogy(180/np.pi*theta3,SL3,label="nodes=700")
plt.title("Scattered intensity (SL) according to the scattering angle $\\theta$")
plt.legend()
plt.show()

# Step 3: Find a given refractive index using PieMyScatt

#### Function computing the scattered intensity for different polarizations
"""

def Intensity(n,k,d,wl,theta):
    S1,S2 = ps.MieS1S2(n+1j*k,np.pi*d/wl,np.cos(theta))
    SL = (np.conjugate(S1)*S1).real
    SR = (np.conjugate(S2)*S2).real
    SU = 1/2*(SR+SL)
    return SL,SR,SU

"""## Inversion for a given diameter d: real number index (using SL)"""

def Inversion_real(I,d,wl,nmin,nmax,tol,pas,theta): 
    error = lambda measured,calculated: np.abs((calculated-measured)/measured)
    n = np.linspace(nmin,nmax,300)
    SL = []
    for i in range(len(n)):
        SL.append(Intensity(n[i],0,d,wl,theta)[0])
    Obj = abs(SL - I )
    plt.plot(n,Obj,label = "|I-I*|")
    condition = False
    i = 0
    _n = []
    _sca = []
    for nb_min in range(7):
        if i<=len(Obj):
            while i<=len(Obj) and not(condition): 
                if Obj[i]-Obj[i+1]>=0:
                    n_index = n[i]
                    sca_index = Obj[i]
                    #print(_n)
                else:
                    condition = True 
                i+=1
            _n.append(n_index)
            _sca.append(sca_index)
            while i<=len(Obj) and Obj[i]-Obj[i+1]<=0:
                i+=1
            condition = False
        else: 
            break 
    plt.plot(_n,_sca,'or',label = "local minimum")
    plt.legend()
    plt.title("Graph of the difference between the given intensity and the calculates ones")
    plt.show()
    return _n , _sca

d = 500
wl = 514.5
theta = 0.5
S1 = ps.MieS1S2(1.33,np.pi*d/wl,np.cos(theta))[0]
I = np.real(np.conjugate(S1)*S1)
Inversion_real(I,d,wl,1,3,0.001,0.005,theta)

"""## Inversion for a given diameter d: purely imaginary index (using SL) """

def Inversion_im(I,d,wl,kmin,kmax,tol,pas,theta): 
    error = lambda measured,calculated: np.abs((calculated-measured)/measured)
    _k = kmin
    _S1 = ps.MieS1S2(_k,np.pi*d/wl,np.cos(theta))[0]
    _I = np.real(np.conjugate(_S1)*S1) 
    Ierr = error(I,_I)
    _k += pas*1j 
    nb_iteration = 1 
    while Ierr >= tol and nb_iteration < 20000:  
        nb_iteration += 1
        _S1 = ps.MieS1S2(_k,np.pi*d/wl,np.cos(theta))[0]
        _I = np.real(np.conjugate(_S1)*S1) 
        Ierr_new = error(I,_I)
        if Ierr_new - Ierr > 0:
            _k -= pas*1j 
            Ierr = Ierr_new
        else: 
            _k += pas*1j
            Ierr= Ierr_new 
    
    return _k

d = 500
wl = 514.5
theta = 0.5
S1 = ps.MieS1S2(0.5j,np.pi*d/wl,np.cos(theta))[0]
I = np.real(np.conjugate(S1)*S1)
Inversion_im(I,d,wl,0.01*1j,1j,0.001,0.005,theta)

"""## Inversion for a complex refractive index for a given diameter d and a given wavelength

Our goal is the find a given complex refractive index written $m = n + ik$ using PieMyScatt librairy. To achieve this task, we used confidence interval of the calculated intensities $I(m)$ (SL,SR and SU) knowing the correct intensity $I^*$.
By finding the intersection points between the possible solutions found by SL and SU, we can reduce the number of complex refractive index that statisfied our minimization problem. Although the number of solution stays to high and we can't find any convergence.

Our function to minimize (objective function) : $\quad min_{m\in \mathbb{C}} \quad |I(m)-I^*|$

#### Choice of the refractive index (m = [n,k])
"""

m = [1.7,0.2]

"""#### First version: Inversion algorithms for each polarization (L,R,U)"""

def intersection(liste1,liste2):
    index=[]
    for tab1 in range(len(liste1)): 
        for tab2 in range(len(liste2)):
            if (liste1[tab1]*0.995<liste2[tab2] and liste2[tab2]<liste1[tab1]*1.015):
                index.append(liste1[tab1])
    filtre=set(index)
    index=list(filtre)
    return index

def Inversion_SR(I,d,wl,nmin,nmax,kmin,kmax,theta,tol):
    n_init = np.linspace(nmin,nmax,50)
    k_init = np.linspace(kmin,kmax,50)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SR = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SR[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[1]
            
    index = np.where(np.logical_and(I*(1-tol)<SR, SR<I*(1+tol)))
    refractive_index = m[index]
    return refractive_index

def Inversion_SL(I,d,wl,nmin,nmax,kmin,kmax,theta, tol):
    
    n_init = np.linspace(nmin,nmax,200)
    k_init = np.linspace(kmin,kmax,200)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SL = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SL[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[0]
            
            
    index = np.where(np.logical_and(I*(1-tol)<SL, SL<I*(1+tol)))
    refractive_index = m[index]
    return refractive_index

def Inversion_SU(I,d,wl,nmin,nmax,kmin,kmax,theta,tol):
    
    n_init = np.linspace(nmin,nmax,200)
    k_init = np.linspace(kmin,kmax,200)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SU = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SU[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[2]
            
            
    index = np.where(np.logical_and(I*(1-tol)<SU, SU<I*(1+tol)))
    refractive_index = m[index]
    return refractive_index

"""#### Our results using intersection between SL and SU results  

"""

d = 500
wl = 514.5
theta = 0.5
tol=0.002
SL,SR,SU = Intensity(m[0],m[1],d,wl,theta)
index_SL = Inversion_SL(SL,d,wl,0,3,0.1,1,theta,tol)
index_SU = Inversion_SU(SU,d,wl,0,3,0.1,1,theta,tol)
index_SR = Inversion_SR(SR,d,wl,0,3,0.1,1,theta,tol)

#print("Refractive indices obtain using SL\n",index_SL)
#print("Refractive indices obtain using SR\n",index_SR)
#print("Refractive indices obtain using SU\n",index_SU)
index = []

index=intersection(index_SL,index_SU)
print("Number of solutions found:",len(index))
print("Refractive indices selected\n")
for i in range(len(index)):
      print(index[i],"\n")
print("Expected index:",m[0]," + ",m[1],"j")

"""#### Second inversion method"""

def Inversion_SL2(I,d,wl,nmin,nmax,kmin,kmax,theta, tol):
    n_init = np.linspace(nmin,nmax,50)
    k_init = np.linspace(kmin,kmax,50)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SL = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SL[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[0]
            
    graph=np.abs(SL-I)
    refractive_index=[]
    graph_ini=np.copy(graph)

    for i in range(tol):
        pt=np.unravel_index(np.argmin(graph, axis=None), graph.shape) #méthode 1
        graph[pt] = 1e9
        refractive_index.append(m[pt])
    return refractive_index

def Inversion_SR2(I,d,wl,nmin,nmax,kmin,kmax,theta, tol):
    n_init = np.linspace(nmin,nmax,50)
    k_init = np.linspace(kmin,kmax,50)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SR = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SR[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[1]
            
    graph=np.abs(SR-I)
    refractive_index=[]
    graph_ini=np.copy(graph)

    for i in range(tol):
        pt=np.unravel_index(np.argmin(graph, axis=None), graph.shape) #méthode 1
        graph[pt] = 1e9
        refractive_index.append(m[pt])
    return refractive_index

def Inversion_SU2(I,d,wl,nmin,nmax,kmin,kmax,theta,tol):
    n_init = np.linspace(nmin,nmax,50)
    k_init = np.linspace(kmin,kmax,50)
    size_n = len(n_init)
    size_k = len(k_init)
    m=np.zeros((size_k,size_n),dtype = complex)
    SU = np.zeros((size_k,size_n))
    for raw in range(size_k):
        for col in range(size_n): 
            m[raw,col]=n_init[col]+k_init[raw]*1j
            SU[raw,col] = Intensity(n_init[col],k_init[raw],d,wl,theta)[2]
            
    graph=np.abs(SU-I)
    refractive_index=[]
    graph_ini=np.copy(graph)

    for i in range(tol):
        pt=np.unravel_index(np.argmin(graph, axis=None), graph.shape) #méthode 1
        graph[pt] = 1e9
        refractive_index.append(m[pt])
    return refractive_index

d = 500
wl = 514.5
theta = 0.5
tol=20
SL2,SR2,SU2 = Intensity(m[0],m[1],d,wl,theta)
index_SL2 = Inversion_SL2(SL,d,wl,0,3,0.1,1,theta,tol)
index_SU2 = Inversion_SU2(SU,d,wl,0,3,0.1,1,theta,tol)
index_SR2 = Inversion_SR2(SR,d,wl,0,3,0.1,1,theta,tol)


#print("Refractive indices obtain using SL2\n", index_SL2)
#print("Refractive indices obtain using SR2\n",index_SR2)
#print("Refractive indices obtain using SU2\n",index_SU2)



index2=intersection(index_SR2,index_SL2)
print("Number of solutions found:",len(index2))
print("Refractive indices selected\n")
for i in range(len(index2)):
      print(index2[i],"\n")
             
print("Expected index:",m[0],"+",m[1],"j")

"""## Evolution of the scattered intensity for purely real or imaginary indices

### Real indices
"""

n_init = np.linspace(1,5,500)
SL=[]
SR = []
SU = []
for i in range(len(n_init)):
    S1,S2 = ps.MieS1S2(n_init[i],np.pi*500/514.5,np.cos(0.5))
    SL.append((np.conjugate(S1)*S1).real) 
    SR.append((np.conjugate(S2)*S2).real)
    SU.append(1/2*(SL[i]+SR[i]))
plt.plot(n_init,SL,label="SL")
plt.plot(n_init,SR,label="SR")
plt.plot(n_init,SU,label="SU")
plt.legend()
plt.title("Intensity depending on n")
plt.show()

"""### Purely imaginary indices"""

init = np.linspace(0.0001,1,50)
k_init = init*1j
SL=[]
SR = []
SU = []
for i in range(len(init)):
    S1,S2 = ps.MieS1S2(k_init[i],np.pi*500/514.5,np.cos(0.5))
    SL.append((np.conjugate(S1)*S1).real) 
    SR.append((np.conjugate(S2)*S2).real)
    SU.append(1/2*(SL[i]+SR[i]))
plt.plot(init,SL,label="SL")
plt.plot(init,SR,label="SR")
plt.plot(init,SU,label="SU")
plt.legend()
plt.title("Intensity depending on k")
plt.show()

"""## Evolution of the intensities (SL,SR,SU) according to complex refractives indices"""

import plotly.graph_objects as go
from matplotlib.contour import QuadContourSet
from matplotlib.collections import LineCollection
def graph3D(I,d,wl,nmin,nmax,kmin,kmax,theta,polarisation):
    k = np.linspace(kmin,kmax,100)
    n = np.linspace(nmin,nmax,200)
    m = np.zeros((len(k),len(n)),dtype = complex)
    pol = np.zeros((len(k),len(n)))
    for raw in range(len(k)):
        for col in range(len(n)):
            m[raw,col] = n[col]+k[raw]*1j
            if polarisation=='SL':
                pol[raw,col] = Intensity(n[col],k[raw],d,wl,theta)[0]
            elif polarisation=='SR':
                pol[raw,col] = Intensity(n[col],k[raw],d,wl,theta)[1]
            elif polarisation=='SU':
                pol[raw,col] =  Intensity(n[col],k[raw],d,wl,theta)[2]
    Obj = abs(pol-I)
   
    fig = go.Figure(data=[(go.Surface(z=Obj))])
    fig.update_traces(contours_z=dict(show=True, usecolormap=True,
                                  highlightcolor="limegreen", project_z=True))
    fig.update_layout(title='Gap between intensities to minimize (using '+polarisation+')', autosize=False,scene_camera_eye=dict(x=1.87, y=0.88, z=-0.64),
                  width=500, height=500,
                  margin=dict(l=65, r=50, b=65, t=90))

    
    fig.show()
    
    
    
    #print(n[88],k[43],Obj[43,88])

d = 500
wl = 514.5
theta = 0.5
SL,SR,SU = Intensity(m[0],m[1],d,wl,theta)
graph3D(SL,d,wl,0,3,0.1,1,theta,'SL')
graph3D(SR,d,wl,0,3,0.1,1,theta,'SR')
graph3D(SU,d,wl,0,3,0.1,1,theta,'SU')

"""According to the previous graphs, we can see that each of the objective function to minimize $I-SL$, $I-SR$ and $I-SU$ owns several minimum. The optimization of these functions won't converge to a unique solution (a unique refractive index). 

"""